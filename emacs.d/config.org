#+TITLE: countingsort's emacs
#+CREATOR: Niclas 'countingsort' Meyer
#+LANGUAGE: en
#+OPTIONS: num:nil
#+ATTR_HTML: :style margin-left: auto; margin-right: auto;

This is heavily inspired by =daedreth='s config.  All credits go to him.

* Installation
** Quick installation
=git clone https://github.com/countingsort/dotfiles=

Then get the =emacs.d= to =~/.emacs.d=

* General emacs settings
** Interface settings
*** Remove startup screen
#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t)
#+END_SRC

*** Remove visual clutter
I need that space, adjust accordingly.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

*** No system beep (it's annoying)
Disabled it on the x server.

#+BEGIN_SRC emacs-lisp
  ; (setq ring-bell-function 'ignore)
#+END_SRC

*** UTF-8 everywhere
I don't see why you wouldn't want this.

#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

*** Highlight current line
Only do this when programming though (also only in GUI).

#+BEGIN_SRC emacs-lisp
  ; (when window-system (add-hook 'prog-mode-hook 'hl-line-mode))
#+END_SRC

*** Pretty symbols
Replaces few keywords with symbols (like lambda).  Only in GUI though.

#+BEGIN_SRC emacs-lisp
  (when window-system
      (use-package pretty-mode
          :ensure t
          :config
          ;(global-pretty-mode t)
          ))
#+END_SRC

** Functionality
*** Stop emacs from creating additional files
Pretty annoying to have all these files around.  Also you should really use git instead of the backup~ files.

#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+END_SRC

*** Shorter yes no prompt
Nobody has time to type that shit.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Async
Let's me do stuff asynchronously.

#+BEGIN_SRC emacs-lisp
(use-package async
    :ensure t
    :config (dired-async-mode 1))
#+END_SRC

** Default Browser
qutebrowser for me.  Change this accordingly.

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")
#+END_SRC

* Terminal
** Don't ask me for the shell everytime
#+BEGIN_SRC emacs-lisp
  (defvar my-term-shell "/bin/zsh")
  (defadvice ansi-term (before force-bash)
    (interactive (list my-term-shell)))
  (ad-activate 'ansi-term)
  (global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC

* projectile
** Enabling it
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode 1))
#+END_SRC

** Use projectile to call make
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<f5>") 'projectile-compile-project)
#+END_SRC

* Dashboard
I don't know, maybe later.

* Modeline
This is so important.  Never underestimate this.  Shows information at all time.

** Spaceline
Got used to this in spacemacs. It's so good.

#+BEGIN_SRC emacs-lisp
  (use-package spaceline
    :ensure t
    :config
      (require 'spaceline-config)
        (setq spaceline-buffer-encoding-abbrev-p nil)
        (setq spaceline-line-column-p nil)
        (setq spaceline-line-p nil)
        (setq powerline-default-separator (quote arrow))
        (spaceline-spacemacs-theme))
#+END_SRC

** No separator
#+BEGIN_SRC emacs-lisp
  (setq powerline-default-separator nil)
#+END_SRC

** Cursor position
#+BEGIN_SRC emacs-lisp
  (setq line-number-mode t)
  (setq column-number-mode t)
#+END_SRC

** Clock
*** Time format
#+BEGIN_SRC emacs-lisp
  (setq display-time-24hr-format t)
  (setq display-time-format "%H:%M - %d %B %Y")
#+END_SRC

*** Enabling the mode
#+BEGIN_SRC emacs-lisp
  (display-time-mode 1)
#+END_SRC

** Battery indicator
=fancy-battery= will be used in GUI emacs.  Otherwise =battery-mode= will be used.

#+BEGIN_SRC emacs-lisp
  (use-package fancy-battery
    :ensure t
    :config
    (setq fancy-battery-show-percentage t)
    (setq battery-update-interval 15)
    (if window-system
        (fancy-battery-mode)
      (display-battery-mode)))
#+END_SRC

* Moving around emacs
Most important stuff in this whole config.  Literally.

** ivy
Awesome.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t)
#+END_SRC

** Better scrolling
#+BEGIN_SRC emacs-lisp
  (setq scroll-conservatively 100)
#+END_SRC

** Switching between windows
=<c-o>= kinda sucks with more than 2 windows.

#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :ensure t
    :config
    (setq switch-window-input-style 'minibuffer)
    (setq switch-window-increase 4)
    (setq switch-window-threshold 2)
    (setq switch-window-shortcut-style 'qwerty)
    (setq switch-window-qwerty-shortcuts
          '("a" "s" "d" "f" "j" "k" "l" "i" "o"))
    :bind
    ([remap other-window] . switch-window))
#+END_SRC

** which-key
Self documenting emacs is best emacs.

#+BEGIN_SRC emacs-lisp
(use-package which-key
    :ensure t
    :config
        (which-key-mode))
#+END_SRC

** Following window splits
#+BEGIN_SRC emacs-lisp
  (defun split-and-follow-horizontally ()
      (interactive)
      (split-window-below)
      (balance-windows)
      (other-window 1))
  (global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

  (defun split-and-follow-vertically ()
      (interactive)
      (split-window-right)
      (balance-windows)
      (other-window 1))
  (global-set-key (kbd "C-x 3") 'split-and-follow-vertically)
#+END_SRC

** Swiper for the better search
Default emacs search sucks.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :bind ("C-s" . 'swiper))
#+END_SRC

** ibuffer instead pof switch-to-buffer
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x b") 'ibuffer)
#+END_SRC

*** expert-mode
When you feel like you know ibuffer, enable this.

#+BEGIN_SRC emacs-lisp
  (setq ibuffer-expert t)
#+END_SRC

* linum-relative-mode
Only enabled in programming related modes, since it messes some stuff up.

#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :ensure t
    :config
      (setq linum-relative-current-symbol "")
      (add-hook 'prog-mode-hook 'linum-relative-mode))
#+END_SRC

* helm
Also a spacemacs habit.

#+BEGIN_SRC emacs-lisp
(use-package helm
    :ensure t
    :bind
        ("C-x C-f" . 'helm-find-files)
        ("C-x C-b" . 'helm-buffers-list)
        ("M-x" . 'helm-M-x)
    :config
        (setq helm-autoresize-max-height 0
            helm-autoresize-min-height 40
            helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t
            helm-recentf-fuzzy-match t
            helm-semantic-fuzzy-match t
            helm-imenu-fuzzy-match t
            helm-split-window-in-side-p nil
            helm-move-to-line-cycle-in-source nil
            helm-ff-search-library-in-sexp t
            helm-scroll-amount 8 
            helm-echo-input-in-header-line t)
    :init
        (helm-mode 1))

(require 'helm-config)
(helm-autoresize-mode 1)
(define-key helm-find-files-map (kbd "C-b") 'helm-find-files-up-one-level)
(define-key helm-find-files-map (kbd "C-f") 'helm-execute-persistent-action)
#+END_SRC

* avy
=M-s= for moving characters.

#+BEGIN_SRC emacs-lisp
(use-package avy
    :ensure t
    :bind
        ("M-s" . avy-goto-char))
#+END_SRC

* Text manipulation
** mark-multiple
Allows you to highlight the cest occurence of a region.  Such joy.  Wow

#+BEGIN_SRC emacs-lisp
(use-package mark-multiple
    :ensure t
    :bind ("C-c q" . 'mark-next-like-this))
#+END_SRC

** ws-butler
Automatically removes trailing spaces in modified lines

#+BEGIN_SRC emacs-lisp
  (use-package ws-butler
    :ensure t
    :config
    (add-hook 'prog-mode-hook #'ws-butler-mode))

#+END_SRC

** inner-word stuff
*** kill-inner-word
Basically =diw= in vim.

#+BEGIN_SRC emacs-lisp
(defun meyni/kill-inner-word ()
    (interactive)
    (save-excursion
        (forward-char 1)
        (backward-word)
        (kill-word 1)))
(global-set-key (kbd "C-c w k") 'meyni/kill-inner-word)
#+END_SRC

*** copy-inner-word
Basically =yiw= in vim.

#+BEGIN_SRC emacs-lisp
(defun meyni/copy-inner-word ()
    (interactive)
    (save-excursion
        (forward-char 1)
        (backward-word)
        (kill-word 1)
        (yank)))
(global-set-key (kbd "C-c w c") 'meyni/copy-inner-word)
#+END_SRC

* Misc
This is nothing major, but every single one of these things adds to the whole experience.

** Quickly open config
Open =~/.emacs.d/config.org=.

#+BEGIN_SRC emacs-lisp
(defun meyni/config-visit ()
    "Opens the config.org"
    (interactive)
    (find-file "~/.emacs.d/config.org"))
(global-set-key (kbd "C-c e") 'meyni/config-visit)
#+END_SRC

** Reload config.org
Reload =~/.emacs.d/config.org= at runtime.

#+BEGIN_SRC emacs-lisp
(defun meyni/config-reload ()
    "Reload the config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
(global-set-key (kbd "C-c r") 'meyni/config-reload)
#+END_SRC

** Kill all buffers
#+BEGIN_SRC emacs-lisp
  (defun kill-all-buffers ()
    (interactive)
    (mapc 'kill-buffer (buffer-list))
    (delete-other-windows))
  (global-set-key (kbd "C-c u") 'kill-all-buffers)
#+END_SRC

** Keybind align
I use =align= fairly often, so it deserves a bind.

#+BEGIN_SRC emacs-lisp
  (global-set-key  (kbd "C-c C-k") 'align)
#+END_SRC

** Beacon
Briefly hightlight the cursor after switching between buffers or workspaces.

#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :ensure t
    :config
    (beacon-mode 1))
#+END_SRC

** Electric
Just auto-close everything (strings, parens, everything).

Set the pair that are gonna be completed.

#+BEGIN_SRC emacs-lisp
(setq electric-pair-pairs '(
                           (?\{ . ?\})
                           (?\( . ?\))
                           (?\[ . ?\])
                           (?\" . ?\")))
#+END_SRC

And enable it.

#+BEGIN_SRC emacs-lisp
(electric-pair-mode t)
#+END_SRC

** rainbow-mode
Let hex-codes be the color they represent.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
    :ensure t
    :init
        (add-hook 'prog-mode-hook 'rainbow-mode))
#+END_SRC

** Show parens
Show matching parens when moving the cursor over one.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

** expand-region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC

* Kill ring
Pretty nifty already. Can't be nifty enough though.

** More entries in the ring
#+BEGIN_SRC emacs-lisp
(setq kill-ring-max 100)
#+END_SRC

** popup-kill-ring
=M-y= now basically shows all your kills.

#+BEGIN_SRC emacs-lisp
(use-package popup-kill-ring
    :ensure t
    :bind ("M-y" . popup-kill-ring))
#+END_SRC

* Programming stuff
Stuff related to programming that's not completion.

** yasnippet
snippets but in great.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (use-package yasnippet-snippets
      :ensure t)
    (yas-reload-all))
#+END_SRC

** flycheck
Syntax checking.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t)
#+END_SRC

** company-mode
Kicks in after .5 secs and 2 chars.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :config
    (setq company-idle-delay 0)
    (setq company-minimum-prefix-length 2))
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "M-n") nil)
    (define-key company-active-map (kbd "M-p") nil)
    (define-key company-active-map (kbd "C-n") #'company-select-next)
    (define-key company-active-map (kbd "C-p") #'company-select-previous))
  ;  (define-key company-active-map (kbd "SPC") #'company-abort))
#+END_SRC

** Language specific
*** Web
**** impatient-mode
#+BEGIN_SRC emacs-lisp
  (use-package impatient-mode
    :ensure t)
#+END_SRC

**** js2-mode
#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode)))
#+END_SRC

**** web-mode
#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :config
    (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.php\\'"   . web-mode)))

#+END_SRC

**** emmet
#+BEGIN_SRC emacs-lisp
    (use-package emmet-mode
      :ensure t
      :config
      (add-hook 'web-mode-hook 'emmet-mode))
#+END_SRC

*** C/C++
**** yasnipet
#+BEGIN_SRC emacs-lisp
  (add-hook 'c++-mode-hook 'yas-minor-mode)
  (add-hook 'c-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck-clang-analyzer
    :ensure t
    :config
    (with-eval-after-load 'flycheck
      (require 'flycheck-clang-analyzer)
      (flycheck-clang-analyzer-setup)))
#+END_SRC

**** company
Requires libclang to be installed.

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'c++-mode-hook 'company-mode)
    (add-hook 'c-mode-hook 'company-mode))

  (use-package company-c-headers
    :ensure t)

  (use-package company-irony
    :ensure t
    :config
    (setq company-backends '((company-c-headers
                              company-dabbrev-code
                              company-irony))))

  (use-package irony
    :ensure t
    :config
    (add-hook 'c++-mode-hook 'irony-mode)
    (add-hook 'c-mode-hook 'irony-mode)
    (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options))
#+END_SRC

**** Indentation
Emacs default indentation sucks. Here's my own.
n
#+BEGIN_SRC emacs-lisp
  (setq c-default-style "bsd"
        c-basic-offset 4)
  (setq tab-width 4)
  (setq indent-tabs-mode t)
#+END_SRC

*** Rust
**** rust-mode
#+BEGIN_SRC emacs-lisp
  (use-package rust-mode)
#+END_SRC

*** Python
**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'yas-minor-mode)
#+END_SRC

**** flycheck
#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'flycheck-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'company
    (add-hook 'python-mode-hook 'company-mode))

  (use-package company-jedi
    :ensure t
    :config
    (require 'company)
    (add-to-list 'company-backends 'company-jedi))

  (defun python-mode-company-init ()
    (setq-local company-backends '((company-jedi
                                    company-etags
                                    company-dabbrev-code))))

  (use-package company-jedi
    :ensure t
    :config
    (require 'company)
    (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC

*** elisp
**** eldoc
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

**** yasnippet
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
#+END_SRC

**** company
#+BEGIN_SRC emacs-lisp
  (add-hook 'eamcs-lisp-mode-hook 'company-mode)

  (use-package slime
    :ensure t
    :config
      (setq inferior-lisp-program "/usr/bin/sbcl")
      (setq slime-contribs '(slime-fancy)))

  (use-package slime-company
    :ensure t
    :init
      (require 'company)
      (slime-setup '(slime-fancy slime-company)))
#+END_SRC

* Git integration
** magit
#+BEGIN_SRC emacs-lisp
(use-package magit
    :ensure t
    :config
        (setq magit-push-always-verify nil)
        (setq git-commit-summery-max-length 50)
    :bind
        ("M-g" . magit-status))
#+END_SRC

* Remote editing
In case I need to edit files over SSH.  Happens rarely but you better be prepared.

** Editing with sudo
Helpful as fuck when using =exwm=.

#+BEGIN_SRC emacs-lisp
(use-package sudo-edit
    :ensure t
    :bind
        ("C-c g" . sudo-edit))
#+END_SRC

* org-mode
** Common settings
#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ")
(setq org-src-fontify-natively t)
(setq org-src-tab-acts-natively t)
(setq org-confirm-babel-evaluate nil)
(setq org-export-with-smart-quotes t)
(setq org-src-window-setup 'current-window)
(add-hook 'org-mode-hook 'org-indent-mode)
#+END_SRC

** Syntax highlighting for HTML exports
#+BEGIN_SRC emacs-lisp
(use-package htmlize
    :ensure t)
#+END_SRC

** Line wrapping
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
    '(lambda ()
        (visual-line-mode 1)))
#+END_SRC

** org-bullets
Makes org-mode look gud.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
    :ensure t
    :config
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
#+END_SRC

** emacs-lisp source template
=<el= TAB-expands to an emacs-lisp block.

#+BEGIN_SRC emacs-lisp
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Export formats
*** Twitter Bootstrap
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
    :ensure t)
#+END_SRC

* Diminish mode
Basically unclutter the holy modeline.

#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :init
    (diminish 'projectile-mode)
    (diminish 'which-key-mode)
    (diminish 'linum-relativ-mode)
    (diminish 'visual-line-mode)
    (diminish 'beacon-mode)
    (diminish 'irony-mode)
    (diminish 'page-break-lines-mode)
    (diminish 'auto-revert-mode)
    (diminish 'helm-mode)
    (diminish 'rainbow-mode))

#+END_SRC

* exwm
** Actual exwm setup
#+BEGIN_SRC emacs-lisp
  (use-package exwm
    :ensure t
    :config
    (require 'exwm-config)
    
    ;; fringe size, most people prefer 1
    (fringe-mode 1)
    
    ;; start emacs as a daemon, use "emacsclient <filename>" to edit files directly
    (server-start)

    ;; fix issues with ido-mode
    (exwm-config-ido)

    ;; start emacs as server
    (server-start)

    (setq exwm-workspace-number 1)

    ;; global / always working keybingings
    (exwm-input-set-key (kbd "s-r") #'exwm-reset)
    (exwm-input-set-key (kbd "s-k") #'exwm-workspace-delete)
    (exwm-input-set-key (kbd "s-w") #'exwm-workspace-swap)

    ;; bind s-<num> to the workspace
    (dotimes (i 10)
      (exwm-input-set-key (kbd (format "s-%d" i))
                          `(lambda ()
                             (interactive)
                             (exwm-workspace-switch-create ,i))))

    ;; simplest launcher, if dmenu stops working
    (exwm-input-set-key (kbd "s-&")
                        (lambda (command)
                          (interactive (list (read-shell-command "$ ")))
                          (start-process-shell-command command nil command)))

    ;; set buffer title to window title except for gimp and java
    (add-hook 'exwm-update-class-hook
              (lambda ()
                (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                            (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (when (or (not exwm-instance-name)
                          (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                  (exwm-workspace-rename-buffer exwm-title))))

    ;; easy way to make keybindings work *only* in line mode
    (push ?\C-q exwm-input-prefix-keys)
    (define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

    ;; simulation keys are keys that exwm will send to the exwm buffer upon inputting a key combination
    (exwm-input-set-simulation-keys
     '(
       ;; movement
       ([?\C-b] . left)
       ([?\M-b] . C-left)
       ([?\C-f] . right)
       ([?\M-f] . C-right)
       ([?\C-p] . up)
       ([?\C-n] . down)
       ([?\C-a] . home)
       ([?\C-e] . end)
       ([?\M-v] . prior)
       ([?\C-v] . next)
       ([?\C-d] . delete)
       ([?\C-k] . (S-end delete))
       ;; cut/paste
       ([?\C-w] . ?\C-x)
       ([?\M-w] . ?\C-c)
       ([?\C-y] . ?\C-v)
       ;; search
       ([?\C-s] . ?\C-f)))

    ;; enable exwm, boring
    (exwm-enable))
#+END_SRC

** Launchers
*** dmenu
#+BEGIN_SRC emacs-lisp
  (use-package dmenu
    :ensure t
    :bind
    ("s-SPC" . 'dmenu))
#+END_SRC

** Start processes
#+BEGIN_SRC emacs-lisp
  (defun exwm-async-run (name)
    (interactive)
    (start-process name nil name))

  (defun meyni/launch-browser ()
    (interactive)
    (exwm-async-run "qutebrowser"))

  (defun meyni/lock-screen ()
    (interactive)
    (exwm-async-run "slock"))
#+END_SRC

** Keybind start processes
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-q") 'meyni/launch-browser)
  (global-set-key (kbd "s-l") 'meyni/lock-screen)
#+END_SRC

* Instant messaging
TODO: Configure

* PDF
** pdf-tools
#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :ensure t
    :config
    (pdf-tools-install))
#+END_SRC
